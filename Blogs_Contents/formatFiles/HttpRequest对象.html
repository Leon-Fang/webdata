[<div class="col-md-9"> 
 <!-- 教程正文主体部分 --> 
 <h1>HttpRequest对象</h1> 
 <small>阅读:&nbsp;29258&nbsp;&nbsp;&nbsp;&nbsp; <a href="#comments">评论</a>：4 </small> 
 <hr> 
 <p>每当一个用户请求发送过来，Django将HTTP数据包中的相关内容，打包成为一个HttpRequest对象，并传递给每个视图函数作为第一位置参数，也就是request，供我们调用。</p> 
 <p>HttpRequest对象中包含了非常多的重要的信息和数据，应该熟练掌握它。</p> 
 <p>类定义：class HttpRequest[source]</p> 
 <h2>一、属性</h2> 
 <p>HttpRequest对象的大部分属性是只读的，除非特别注明。</p> 
 <h3>1. HttpRequest.scheme</h3> 
 <p>字符串类型，表示请求的协议种类，'http'或'https'。</p> 
 <h3>2. HttpRequest.body</h3> 
 <p>bytes类型，表示原始HTTP请求的正文。它对于处理非HTML形式的数据非常有用：二进制图像、XML等。如果要处理常规的表单数据，应该使用HttpRequest.POST。</p> 
 <p>还可以使用类似读写文件的方式从HttpRequest中读取数据，参见HttpRequest.read()。</p> 
 <h3>3. HttpRequest.path</h3> 
 <p>字符串类型，表示当前请求页面的完整路径，但是不包括协议名和域名。例如："/music/bands/the_beatles/"。这个属性，常被用于我们进行某项操作时，如果不通过，返回用户先前浏览的页面。非常有用！</p> 
 <h3>4. HttpRequest.path_info</h3> 
 <p>在某些Web服务器配置下，主机名后的URL部分被分成脚本前缀部分和路径信息部分。<code>path_info</code> 属性将始终包含路径信息部分，不论使用的Web服务器是什么。使用它代替path可以让代码在测试和开发环境中更容易地切换。</p> 
 <p>例如，如果应用的WSGIScriptAlias设置为<code>/minfo</code>，那么<code>HttpRequest.path</code>等于<code>/music/bands/the_beatles/</code> ，而<code>HttpRequest.path_info</code>为<code>/minfo/music/bands/the_beatles/</code>。</p> 
 <h3>5. HttpRequest.method</h3> 
 <p>字符串类型，表示请求使用的HTTP方法。默认为大写。 像这样：</p> 
 <div class="codehilite">
  <pre><span></span>if request.method == 'GET':
    do_something()
elif request.method == 'POST':
    do_something_else()
</pre>
 </div> 
 <p>通过这个属性来判断请求的方法，然后根据请求的方法不同，在视图中执行不同的代码。</p> 
 <h3>6. HttpRequest.encoding</h3> 
 <p>字符串类型，表示提交的数据的编码方式（如果为None 则表示使用<code>DEFAULT_CHARSET</code>设置）。 这个属性是可写的，可以通过修改它来改变表单数据的编码。任何随后的属性访问（例如GET或POST）将使用新的编码方式。</p> 
 <h3>7. HttpRequest.content_type</h3> 
 <p>Django1.10中新增。表示从<code>CONTENT_TYPE</code>头解析的请求的MIME类型。</p> 
 <h3>8. HttpRequest.content_params</h3> 
 <p>Django 1.10中新增。包含在<code>CONTENT_TYPE</code>标题中的键/值参数字典。</p> 
 <h3>9 HttpRequest.GET</h3> 
 <p>一个类似于字典的对象，包含GET请求中的所有参数。 详情参考QueryDict文档。</p> 
 <h3>10. HttpRequest.POST</h3> 
 <p>一个包含所有POST请求的参数，以及包含表单数据的字典。 详情请参考QueryDict文档。 如果需要访问请求中的原始或非表单数据，可以使用<code>HttpRequest.body</code>属性。</p> 
 <p>注意：请使用<code>if request.method == "POST"</code>来判断一个请求是否POST类型，而不要使用<code>if request.POST</code>。</p> 
 <p>POST中不包含上传文件的数据。 </p> 
 <h3>11. HttpRequest.COOKIES</h3> 
 <p>包含所有Cookie信息的字典。 键和值都为字符串。可以类似字典类型的方式，在cookie中读写数据，但是注意cookie是不安全的，因此，不要写敏感重要的信息。</p> 
 <h3>12. HttpRequest.FILES</h3> 
 <p>一个类似于字典的对象，包含所有上传的文件数据。 FILES中的每个键为<code>&lt;input type="file" name="" /&gt;</code>中的name属性值。 FILES中的每个值是一个<code>UploadedFile</code>。</p> 
 <p>要在Django中实现文件上传，就要靠这个属性！</p> 
 <p>如果请求方法是POST且请求的<code>&lt;form&gt;</code>中带有<code>enctype="multipart/form-data"</code>属性，那么FILES将包含上传的文件的数据。 否则，FILES将为一个空的类似于字典的对象，属于被忽略、无用的情形。</p> 
 <h3>13. HttpRequest.META</h3> 
 <p>包含所有HTTP头部信息的字典。 可用的头部信息取决于客户端和服务器，下面是一些示例：</p> 
 <ul> 
  <li>CONTENT_LENGTH —— 请求正文的长度（以字符串计）。</li> 
  <li>CONTENT_TYPE —— 请求正文的MIME类型。</li> 
  <li>HTTP_ACCEPT —— 可接收的响应<code>Content-Type</code>。</li> 
  <li>HTTP_ACCEPT_ENCODING —— 可接收的响应编码类型。</li> 
  <li>HTTP_ACCEPT_LANGUAGE —— 可接收的响应语言种类。</li> 
  <li>HTTP_HOST —— 客服端发送的Host头部。</li> 
  <li>HTTP_REFERER —— Referring页面。</li> 
  <li>HTTP_USER_AGENT —— 客户端的<code>user-agent</code>字符串。</li> 
  <li>QUERY_STRING —— 查询字符串。</li> 
  <li>REMOTE_ADDR —— 客户端的IP地址。想要获取客户端的ip信息，就在这里！</li> 
  <li>REMOTE_HOST —— 客户端的主机名。</li> 
  <li>REMOTE_USER —— 服务器认证后的用户，如果可用。</li> 
  <li>REQUEST_METHOD —— 表示请求方法的字符串，例如"GET" 或"POST"。</li> 
  <li>SERVER_NAME —— 服务器的主机名。</li> 
  <li>SERVER_PORT —— 服务器的端口（字符串）。</li> 
 </ul> 
 <p>以上只是比较重要和常用的，还有很多未列出。</p> 
 <p>从上面可以看到，除<code>CONTENT_LENGTH</code>和<code>CONTENT_TYPE</code>之外，请求中的任何HTTP头部键转换为META键时，都会将所有字母大写并将连接符替换为下划线最后加上<code>HTTP_</code>前缀。所以，一个叫做<code>X-Bender</code>的头部将转换成META中的<code>HTTP_X_BENDER</code>键。</p> 
 <h3>13. HttpRequest.resolver_match</h3> 
 <p>代表一个已解析的URL的ResolverMatch实例。 </p> 
 <h2>二、可自定义的属性</h2> 
 <p>Django不会自动设置下面这些属性，而是由你自己在应用程序中设置并使用它们。</p> 
 <h3>1. HttpRequest.current_app</h3> 
 <p>表示当前app的名字。url模板标签将使用其值作为<code>reverse()</code>方法的<code>current_app</code>参数。</p> 
 <h3>2. HttpRequest.urlconf</h3> 
 <p>设置当前请求的根<code>URLconf</code>，用于指定不同的url路由进入口，这将覆盖settings中的<code>ROOT_URLCONF</code>设置。</p> 
 <p>将它的值修改为None，可以恢复使用<code>ROOT_URLCONF</code>设置。</p> 
 <h2>三、由中间件设置的属性</h2> 
 <p>Django的contrib应用中包含的一些中间件会在请求上设置属性。</p> 
 <h3>1. HttpRequest.session</h3> 
 <p>SessionMiddleware中间件：一个可读写的，类似字典的对象，表示当前会话。我们要保存用户状态，回话过程等等，靠的就是这个中间件和这个属性。</p> 
 <h3>2. HttpRequest.site</h3> 
 <p>CurrentSiteMiddleware中间件：<code>get_current_site()</code>方法返回的Site或RequestSite的实例，代表当前站点是哪个。</p> 
 <p>Django是支持多站点的，如果你同时上线了几个站点，就需要为每个站点设置一个站点id。</p> 
 <h3>3. HttpRequest.user</h3> 
 <p>AuthenticationMiddleware中间件：表示当前登录的用户的<code>AUTH_USER_MODEL</code>的实例，这个模型是Django内置的Auth模块下的User模型。如果用户当前未登录，则user将被设置为<code>AnonymousUser</code>的实例。 </p> 
 <p>可以使用<code>is_authenticated</code>方法判断当前用户是否合法用户，如下所示：</p> 
 <div class="codehilite">
  <pre><span></span>if request.user.is_authenticated:
    ... # Do something for logged-in users.
else:
    ... # Do something for anonymous users.
</pre>
 </div> 
 <h2>四、方法</h2> 
 <h3>1. HttpRequest.get_host()[source]</h3> 
 <p>根据<code>HTTP_X_FORWARDED_HOST</code>和<code>HTTP_HOST</code>头部信息获取请求的原始主机。 如果这两个头部没有提供相应的值，则使用<code>SERVER_NAME</code>和<code>SERVER_PORT</code>。</p> 
 <p>例如："127.0.0.1:8000"</p> 
 <p>注：当主机位于多个代理的后面，<code>get_host()</code>方法将会失败。解决办法之一是使用中间件重写代理的头部，如下面的例子：</p> 
 <div class="codehilite">
  <pre><span></span><span class="kn">from</span> <span class="nn">django.utils.deprecation</span> <span class="kn">import</span> <span class="n">MiddlewareMixin</span>

<span class="k">class</span> <span class="nc">MultipleProxyMiddleware</span><span class="p">(</span><span class="n">MiddlewareMixin</span><span class="p">):</span>
    <span class="n">FORWARDED_FOR_FIELDS</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s1">'HTTP_X_FORWARDED_FOR'</span><span class="p">,</span>
        <span class="s1">'HTTP_X_FORWARDED_HOST'</span><span class="p">,</span>
        <span class="s1">'HTTP_X_FORWARDED_SERVER'</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">def</span> <span class="nf">process_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Rewrites the proxy headers so that only the most</span>
<span class="sd">        recent proxy is used.</span>
<span class="sd">        """</span>
        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">FORWARDED_FOR_FIELDS</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">request</span><span class="o">.</span><span class="n">META</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">','</span> <span class="ow">in</span> <span class="n">request</span><span class="o">.</span><span class="n">META</span><span class="p">[</span><span class="n">field</span><span class="p">]:</span>
                    <span class="n">parts</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="n">META</span><span class="p">[</span><span class="n">field</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">','</span><span class="p">)</span>
                    <span class="n">request</span><span class="o">.</span><span class="n">META</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
</pre>
 </div> 
 <h3>2. HttpRequest.get_port()[source]</h3> 
 <p>使用META中<code>HTTP_X_FORWARDED_PORT</code>和<code>SERVER_PORT</code>的信息返回请求的始发端口。</p> 
 <h3>3. HttpRequest.get_full_path()[source]</h3> 
 <p>返回包含完整参数列表的path。例如：<code>/music/bands/the_beatles/?print=true</code></p> 
 <h3>4. HttpRequest.build_absolute_uri(location)[source]</h3> 
 <p>返回location的绝对URI形式。 如果location没有提供，则使用<code>request.get_full_path()</code>的值。</p> 
 <p>例如："https://example.com/music/bands/the_beatles/?print=true"</p> 
 <p>注：不鼓励在同一站点混合部署HTTP和HTTPS，如果需要将用户重定向到HTTPS，最好使用Web服务器将所有HTTP流量重定向到HTTPS。</p> 
 <h3>5. HttpRequest.get_signed_cookie(key, default=RAISE_ERROR, salt='', max_age=None)[source]</h3> 
 <p>从已签名的Cookie中获取值，如果签名不合法则返回django.core.signing.BadSignature。 </p> 
 <p>可选参数salt用来为密码加盐，提高安全系数。 <code>max_age</code>参数用于检查Cookie对应的时间戳是否超时。</p> 
 <p>范例：</p> 
 <div class="codehilite">
  <pre><span></span>&gt;&gt;&gt; request.get_signed_cookie('name')
'Tony'
&gt;&gt;&gt; request.get_signed_cookie('name', salt='name-salt')
'Tony' # assuming cookie was set using the same salt
&gt;&gt;&gt; request.get_signed_cookie('non-existing-cookie')
...
KeyError: 'non-existing-cookie'
&gt;&gt;&gt; request.get_signed_cookie('non-existing-cookie', False)
False
&gt;&gt;&gt; request.get_signed_cookie('cookie-that-was-tampered-with')
...
BadSignature: ...
&gt;&gt;&gt; request.get_signed_cookie('name', max_age=60)
...
SignatureExpired: Signature age 1677.3839159 &gt; 60 seconds
&gt;&gt;&gt; request.get_signed_cookie('name', False, max_age=60)
False
</pre>
 </div> 
 <h3>6. HttpRequest.is_secure()[source]</h3> 
 <p>如果使用的是Https，则返回True，表示连接是安全的。</p> 
 <h3>7. HttpRequest.is_ajax()[source]</h3> 
 <p>如果请求是通过XMLHttpRequest生成的，则返回True。</p> 
 <p>这个方法的作用就是判断，当前请求是否通过ajax机制发送过来的。</p> 
 <h3>8. HttpRequest.read(size=None)[source]</h3> 
 <h3>9. HttpRequest.readline()[source]</h3> 
 <h3>10. HttpRequest.readlines()[source]</h3> 
 <h3>11. HttpRequest.xreadlines()[source]</h3> 
 <h3>12. HttpRequest.<strong>iter</strong>()</h3> 
 <p>上面的几个方法都是从HttpRequest实例读取文件数据的方法。</p> 
 <p>可以将HttpRequest实例直接传递到XML解析器，例如ElementTree：</p> 
 <div class="codehilite">
  <pre><span></span><span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span> <span class="kn">as</span> <span class="nn">ET</span>
<span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">ET</span><span class="o">.</span><span class="n">iterparse</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">process</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
</pre>
 </div> 
 <hr> 
 <!-- 教程导航条 --> 
 <div> 
  <a href="/course/django/137"> <i class="fa fa-arrow-left"></i>&nbsp;视图函数及快捷方式</a> 
  <a class="float-right" href="/course/django/139"> QueryDict对象&nbsp;<i class="fa fa-arrow-right"></i></a> 
 </div> 
 <!-- 教程导航条结束 --> 
 <hr> 
 <!-- 评论区--> 
 <!-- 显示评论条数--> 
 <h4>评论总数： 4</h4> 
 <hr> 
 <!-- 评论表单区--> 
 <div> 
  <a class="text-danger" href="https://api.weibo.com/oauth2/authorize?client_id=3191049160&amp;response_type=code&amp;redirect_uri=http://www.liujiangblog.com/login?next=/course/django/138">点击登录后方可评论</a> 
 </div> 
 <!-- 评论表单区结束--> 
 <hr> 
 <!-- 评论显示区--> 
 <div id="comments"> 
  <div class="comment " style="margin-left: 0em"> 
   <div class="row"> 
    <div> 
     <img src="https://tvax1.sinaimg.cn/crop.0.0.996.996.50/005xnqAIly8fr8i0bgjewj30ro0roabw.jpg?KID=imgbed,tva&amp;Expires=1566966441&amp;ssig=JL4WeUH3fG" alt="user_image"> 
    </div> 
    <div class="comment-content  col-md-10"> 
     <p>刘老师，那个path和path_info的例子是不是写反了，path_info不是路径部分吗？</p> 
     <br> 
     <div class="comment_footer small mute"> 
      <span>By&nbsp;&nbsp; 尴尬村村长 </span>&nbsp;&nbsp;&nbsp;On&nbsp;&nbsp; 
      <em>2019年8月28日 09:29</em>&nbsp;&nbsp; 
      <a class="text-info" href="/reply/1599">回复</a> 
     </div> 
     <br> 
    </div> 
   </div> 
  </div> 
  <div class="comment " style="margin-left: 0em"> 
   <div class="row"> 
    <div> 
     <img src="http://tva1.sinaimg.cn/crop.0.0.170.170.50/006tWIPVjw8f48jgpx676j304q04qt8h.jpg" alt="user_image"> 
    </div> 
    <div class="comment-content  col-md-10"> 
     <p>内容太概括抽象了。只好先通读几遍，有个大概印象。</p> 
     <br> 
     <div class="comment_footer small mute"> 
      <span>By&nbsp;&nbsp; Zzz321A </span>&nbsp;&nbsp;&nbsp;On&nbsp;&nbsp; 
      <em>2019年4月9日 09:36</em>&nbsp;&nbsp; 
      <a class="text-info" href="/reply/1232">回复</a> 
     </div> 
     <br> 
    </div> 
   </div> 
  </div> 
  <div class="comment " style="margin-left: 0em"> 
   <div class="row"> 
    <div> 
     <img src="http://tvax1.sinaimg.cn/crop.0.0.996.996.50/006xIWURly8fu5i5w2xi6j30ro0ro75p.jpg" alt="user_image"> 
    </div> 
    <div class="comment-content  col-md-10"> 
     <p>HttpRequest.META['REMOTE_ADDR']获取的并不是真实的客户机IP！比如本地获取的是“127.0.0.1”，而不是真正的IPv4中的IP。那么，如何获取真实的客户端IP呢？</p> 
     <br> 
     <div class="comment_footer small mute"> 
      <span>By&nbsp;&nbsp; 蔷薇-Nina </span>&nbsp;&nbsp;&nbsp;On&nbsp;&nbsp; 
      <em>2018年9月9日 19:49</em>&nbsp;&nbsp; 
      <a class="text-info" href="/reply/723">回复</a> 
     </div> 
     <br> 
    </div> 
   </div> 
  </div> 
  <div class="comment " style="margin-left: 4em"> 
   <div class="row"> 
    <div> 
     <img src="http://tvax1.sinaimg.cn/crop.0.0.996.996.50/006xIWURly8fu5i5w2xi6j30ro0ro75p.jpg" alt="user_image"> 
    </div> 
    <div class="comment-content  col-md-10"> 
     <p>1.需要准备远程机测试才准确； 2.需要考虑是否部署了Nginx代理。</p> 
     <br> 
     <div class="comment_footer small mute"> 
      <span> 蔷薇-Nina &nbsp;&nbsp;回复&nbsp;&nbsp; 蔷薇-Nina </span> 
      <em>2018年9月9日 21:52</em>&nbsp;&nbsp; 
      <a class="text-info" href="/reply/724">回复</a> 
     </div> 
     <br> 
    </div> 
   </div> 
  </div> 
  <!-- 评论显示区结束--> 
  <!-- 评论区结束--> 
 </div> 
 <!-- 右侧正文栏结束 --> 
</div>]
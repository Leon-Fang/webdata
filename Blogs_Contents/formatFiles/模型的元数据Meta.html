[<div class="col-md-9"> 
 <!-- 教程正文主体部分 --> 
 <h1>模型的元数据Meta</h1> 
 <small>阅读:&nbsp;42910&nbsp;&nbsp;&nbsp;&nbsp; <a href="#comments">评论</a>：7 </small> 
 <hr> 
 <p>模型的元数据，指的是“除了字段外的所有内容”，例如排序方式、数据库表名、人类可读的单数或者复数名等等。所有的这些都是非必须的，甚至元数据本身对模型也是非必须的。但是，我要说但是，有些元数据选项能给予你极大的帮助，在实际使用中具有重要的作用，是实际应用的‘必须’。</p> 
 <p>想在模型中增加元数据，方法很简单，在模型类中添加一个子类，名字是固定的<code>Meta</code>，然后在这个Meta类下面增加各种元数据选项或者说设置项。参考下面的例子：</p> 
 <div class="codehilite">
  <pre><span></span><span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>

<span class="k">class</span> <span class="nc">Ox</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">horn_length</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">IntegerField</span><span class="p">()</span>

    <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>         <span class="c1"># 注意，是模型的子类，要缩进！</span>
        <span class="n">ordering</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"horn_length"</span><span class="p">]</span>
        <span class="n">verbose_name_plural</span> <span class="o">=</span> <span class="s2">"oxen"</span>
</pre>
 </div> 
 <p>上面的例子中，我们为模型Ox增加了两个元数据‘ordering’和‘verbose_name_plural’，分别表示排序和复数名，下面我们会详细介绍有哪些可用的元数据选项。</p> 
 <p><strong>强调：每个模型都可以有自己的元数据类，每个元数据类也只对自己所在模型起作用。</strong></p> 
 <hr> 
 <h3>abstract</h3> 
 <p>如果<code>abstract=True</code>，那么模型会被认为是一个抽象模型。抽象模型本身不实际生成数据库表，而是作为其它模型的父类，被继承使用。具体内容可以参考Django模型的继承。</p> 
 <hr> 
 <h3>app_label</h3> 
 <p>如果定义了模型的app没有在<code>INSTALLED_APPS</code>中注册，则必须通过此元选项声明它属于哪个app，例如：</p> 
 <div class="codehilite">
  <pre><span></span>app_label = 'myapp'
</pre>
 </div> 
 <hr> 
 <h3>base_manager_name</h3> 
 <p>自定义模型的<code>_base_manager</code>管理器的名字。模型管理器是Django为模型提供的API所在。Django1.10新增。</p> 
 <hr> 
 <h3>db_table</h3> 
 <p>指定在数据库中，当前模型生成的数据表的表名。比如：</p> 
 <div class="codehilite">
  <pre><span></span>db_table = 'my_freinds'
</pre>
 </div> 
 <p>友情建议：使用MySQL数据库时，<code>db_table</code>用小写英文。</p> 
 <hr> 
 <h3>db_tablespace</h3> 
 <p>自定义数据库表空间的名字。默认值是工程的<code>DEFAULT_TABLESPACE</code>设置。</p> 
 <hr> 
 <h3>default_manager_name</h3> 
 <p>自定义模型的<code>_default_manager</code>管理器的名字。Django1.10新增。</p> 
 <hr> 
 <h3>default_related_name</h3> 
 <p>默认情况下，从一个模型反向关联设置有关系字段的源模型，我们使用<code>&lt;model_name&gt;_set</code>，也就是源模型的名字+下划线+<code>set</code>。</p> 
 <p>这个元数据选项可以让你自定义反向关系名，同时也影响反向查询关系名！看下面的例子：</p> 
 <div class="codehilite">
  <pre><span></span><span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Bar</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">foo</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>
        <span class="n">default_related_name</span> <span class="o">=</span> <span class="s1">'bars'</span>   <span class="c1"># 关键在这里</span>
</pre>
 </div> 
 <p>具体的使用差别如下：</p> 
 <div class="codehilite">
  <pre><span></span>&gt;&gt;&gt; bar = Bar.objects.get(pk=1)
&gt;&gt;&gt; # 不能再使用"bar"作为反向查询的关键字了。
&gt;&gt;&gt; Foo.objects.get(bar=bar)
&gt;&gt;&gt; # 而要使用你自己定义的"bars"了。
&gt;&gt;&gt; Foo.objects.get(bars=bar)
</pre>
 </div> 
 <hr> 
 <h3>get_latest_by</h3> 
 <p>Django管理器给我们提供有latest()和earliest()方法，分别表示获取最近一个和最前一个数据对象。但是，如何来判断最近一个和最前面一个呢？也就是根据什么来排序呢？</p> 
 <p><code>get_latest_by</code>元数据选项帮你解决这个问题，它可以指定一个类似 <code>DateField</code>、<code>DateTimeField</code>或者<code>IntegerField</code>这种可以排序的字段，作为latest()和earliest()方法的排序依据，从而得出最近一个或最前面一个对象。例如：</p> 
 <div class="codehilite">
  <pre><span></span>get_latest_by = "order_date"
</pre>
 </div> 
 <hr> 
 <h3>managed</h3> 
 <p>该元数据默认值为True，表示Django将按照既定的规则，管理数据库表的生命周期。</p> 
 <p>如果设置为False，将不会针对当前模型创建和删除数据库表。在某些场景下，这可能有用，但更多时候，你可以忘记该选项。</p> 
 <hr> 
 <h3>order_with_respect_to</h3> 
 <p>这个选项不好理解。其用途是根据指定的字段进行排序，通常用于关系字段。看下面的例子：</p> 
 <div class="codehilite">
  <pre><span></span><span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>

<span class="k">class</span> <span class="nc">Question</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">TextField</span><span class="p">()</span>
    <span class="c1"># ...</span>

<span class="k">class</span> <span class="nc">Answer</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">question</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="n">Question</span><span class="p">,</span> <span class="n">on_delete</span><span class="o">=</span><span class="n">models</span><span class="o">.</span><span class="n">CASCADE</span><span class="p">)</span>
    <span class="c1"># ...</span>

    <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>
        <span class="n">order_with_respect_to</span> <span class="o">=</span> <span class="s1">'question'</span>
</pre>
 </div> 
 <p>上面在Answer模型中设置了<code>order_with_respect_to = 'question'</code>，这样的话，Django会自动提供两个API，<code>get_RELATED_order()</code>和<code>set_RELATED_order()</code>，其中的<code>RELATED</code>用小写的模型名代替。假设现在有一个Question对象，它关联着多个Answer对象，下面的操作返回包含关联的Anser对象的主键的列表[1,2,3]：</p> 
 <div class="codehilite">
  <pre><span></span>&gt;&gt;&gt; question = Question.objects.get(id=1)
&gt;&gt;&gt; question.get_answer_order()
[1, 2, 3]
</pre>
 </div> 
 <p>我们可以通过<code>set_RELATED_order()</code>方法，指定上面这个列表的顺序：</p> 
 <div class="codehilite">
  <pre><span></span>&gt;&gt;&gt; question.set_answer_order([3, 1, 2])
</pre>
 </div> 
 <p>同样的，关联的对象也获得了两个方法<code>get_next_in_order()</code>和<code>get_previous_in_order()</code>，用于通过特定的顺序访问对象，如下所示：</p> 
 <div class="codehilite">
  <pre><span></span>&gt;&gt;&gt; answer = Answer.objects.get(id=2)
&gt;&gt;&gt; answer.get_next_in_order()
&lt;Answer: 3&gt;
&gt;&gt;&gt; answer.get_previous_in_order()
&lt;Answer: 1&gt;
</pre>
 </div> 
 <p>这个元数据的作用......还没用过，囧。</p> 
 <hr> 
 <h3>ordering</h3> 
 <p>最常用的元数据之一了！</p> 
 <p>用于指定该模型生成的所有对象的排序方式，接收一个字段名组成的元组或列表。默认按升序排列，如果在字段名前加上字符“-”则表示按降序排列，如果使用字符问号“？”表示随机排列。请看下面的例子：</p> 
 <div class="codehilite">
  <pre><span></span>ordering = ['pub_date']             # 表示按'pub_date'字段进行升序排列
ordering = ['-pub_date']            # 表示按'pub_date'字段进行降序排列
ordering = ['-pub_date', 'author']  # 表示先按'pub_date'字段进行降序排列，再按`author`字段进行升序排列。
</pre>
 </div> 
 <hr> 
 <h3>permissions</h3> 
 <p>该元数据用于当创建对象时增加额外的权限。它接收一个所有元素都是二元元组的列表或元组，每个元素都是<code>(权限代码, 直观的权限名称)</code>的格式。比如下面的例子：</p> 
 <div class="codehilite">
  <pre><span></span>permissions = (("can_deliver_pizzas", "可以送披萨"),)
</pre>
 </div> 
 <hr> 
 <h3>default_permissions</h3> 
 <p>Django默认给所有的模型设置('add', 'change', 'delete')的权限，也就是增删改。你可以自定义这个选项，比如设置为一个空列表，表示你不需要默认的权限，但是这一操作必须在执行migrate命令之前。</p> 
 <hr> 
 <h3>proxy</h3> 
 <p>如果设置了<code>proxy = True</code>，表示使用代理模式的模型继承方式。具体内容与abstract选项一样，参考模型继承章节。</p> 
 <hr> 
 <h3>required_db_features</h3> 
 <p>声明模型依赖的数据库功能。比如['gis_enabled']，表示模型的建立依赖GIS功能。</p> 
 <hr> 
 <h3>required_db_vendor</h3> 
 <p>声明模型支持的数据库。Django默认支持<code>sqlite, postgresql, mysql, oracle</code>。</p> 
 <hr> 
 <h3>select_on_save</h3> 
 <p>决定是否使用1.6版本之前的<code>django.db.models.Model.save()</code>算法保存对象。默认值为False。这个选项我们通常不用关心。</p> 
 <hr> 
 <h3>indexes</h3> 
 <p>Django1.11新增的选项。</p> 
 <p>接收一个应用在当前模型上的索引列表，如下例所示：</p> 
 <div class="codehilite">
  <pre><span></span><span class="kn">from</span> <span class="nn">django.db</span> <span class="kn">import</span> <span class="n">models</span>

<span class="k">class</span> <span class="nc">Customer</span><span class="p">(</span><span class="n">models</span><span class="o">.</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">first_name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">last_name</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">CharField</span><span class="p">(</span><span class="n">max_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">Meta</span><span class="p">:</span>
        <span class="n">indexes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">models</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="s1">'last_name'</span><span class="p">,</span> <span class="s1">'first_name'</span><span class="p">]),</span>
            <span class="n">models</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">fields</span><span class="o">=</span><span class="p">[</span><span class="s1">'first_name'</span><span class="p">],</span> <span class="n">name</span><span class="o">=</span><span class="s1">'first_name_idx'</span><span class="p">),</span>
        <span class="p">]</span>
</pre>
 </div> 
 <hr> 
 <h3>unique_together</h3> 
 <p>这个元数据是非常重要的一个！它等同于数据库的联合约束！</p> 
 <p>举个例子，假设有一张用户表，保存有用户的姓名、出生日期、性别和籍贯等等信息。要求是所有的用户唯一不重复，可现在有好几个叫“张伟”的，如何区别它们呢？（不要和我说主键唯一，这里讨论的不是这个问题）</p> 
 <p>我们可以设置不能有两个用户在同一个地方同一时刻出生并且都叫“张伟”，使用这种联合约束，保证数据库能不能重复添加用户（也不要和我谈小概率问题）。在Django的模型中，如何实现这种约束呢？</p> 
 <p>使用<code>unique_together</code>，也就是联合唯一！</p> 
 <p>比如：</p> 
 <div class="codehilite">
  <pre><span></span>unique_together = (('name', 'birth_day', 'address'),)
</pre>
 </div> 
 <p>这样，哪怕有两个在同一天出生的张伟，但他们的籍贯不同，也就是两个不同的用户。一旦三者都相同，则会被Django拒绝创建。这一元数据经常被用在admin后台，并且强制应用于数据库层面。</p> 
 <p>unique_together接收一个二维的元组((xx,xx,xx,...),(),(),()...)，每一个元素都是一个元组，表示一组联合唯一约束，可以同时设置多组约束。为了方便，对于只有一组约束的情况下，可以简单地使用一维元素，例如：</p> 
 <div class="codehilite">
  <pre><span></span>unique_together = ('name', 'birth_day', 'address')
</pre>
 </div> 
 <p>联合唯一无法作用于普通的多对多字段。</p> 
 <hr> 
 <h3>index_together</h3> 
 <p>即将废弃，使用<code>index</code>元数据代替。</p> 
 <hr> 
 <h3>verbose_name</h3> 
 <p>最常用的元数据之一！用于设置模型对象的直观、人类可读的名称。可以用中文。例如：</p> 
 <div class="codehilite">
  <pre><span></span>verbose_name = "story"
verbose_name = "披萨"
</pre>
 </div> 
 <p>如果你不指定它，那么Django会使用小写的模型名作为默认值。</p> 
 <hr> 
 <h3>verbose_name_plural</h3> 
 <p>英语有单数和复数形式。这个就是模型对象的复数名，比如“apples”。因为我们中文通常不区分单复数，所以保持和<code>verbose_name</code>一致也可以。</p> 
 <div class="codehilite">
  <pre><span></span>verbose_name_plural = "stories"
verbose_name_plural = "披萨"
</pre>
 </div> 
 <p>如果不指定该选项，那么默认的复数名字是<code>verbose_name</code>加上‘s’</p> 
 <hr> 
 <h3>label</h3> 
 <p>前面介绍的元数据都是可修改和设置的，但还有两个只读的元数据，label就是其中之一。</p> 
 <p>label等同于<code>app_label.object_name</code>。例如<code>polls.Question</code>，polls是应用名，Question是模型名。</p> 
 <hr> 
 <h3>label_lower</h3> 
 <p>同上，不过是小写的模型名。</p> 
 <hr> 
 <!-- 教程导航条 --> 
 <div> 
  <a href="/course/django/98"> <i class="fa fa-arrow-left"></i>&nbsp;多对多中间表详解</a> 
  <a class="float-right" href="/course/django/100"> 模型的继承&nbsp;<i class="fa fa-arrow-right"></i></a> 
 </div> 
 <!-- 教程导航条结束 --> 
 <hr> 
 <!-- 评论区--> 
 <!-- 显示评论条数--> 
 <h4>评论总数： 7</h4> 
 <hr> 
 <!-- 评论表单区--> 
 <div> 
  <a class="text-danger" href="https://api.weibo.com/oauth2/authorize?client_id=3191049160&amp;response_type=code&amp;redirect_uri=http://www.liujiangblog.com/login?next=/course/django/99">点击登录后方可评论</a> 
 </div> 
 <!-- 评论表单区结束--> 
 <hr> 
 <!-- 评论显示区--> 
 <div id="comments"> 
  <div class="comment " style="margin-left: 0em"> 
   <div class="row"> 
    <div> 
     <img src="https://tva4.sinaimg.cn/crop.171.162.444.444.50/a1b3ec11jw8eow1puatufj20m80m83z2.jpg?KID=imgbed,tva&amp;Expires=1587150583&amp;ssig=cPGmxi%2F9go" alt="user_image"> 
    </div> 
    <div class="comment-content  col-md-10"> 
     <p>unique_together 的介绍中，有一句话应该是写错了吧？ 同时设置多组约束。为了方便，对于只有一组约束的情况下，可以简单地使用一维元素，例如： 是不是应该是一维元组</p> 
     <br> 
     <div class="comment_footer small mute"> 
      <span>By&nbsp;&nbsp; 好奇葩网 </span>&nbsp;&nbsp;&nbsp;On&nbsp;&nbsp; 
      <em>2020年4月18日 00:11</em>&nbsp;&nbsp; 
      <a class="text-info" href="/reply/2042">回复</a> 
     </div> 
     <br> 
    </div> 
   </div> 
  </div> 
  <div class="comment " style="margin-left: 0em"> 
   <div class="row"> 
    <div> 
     <img src="https://tva2.sinaimg.cn/crop.0.0.180.180.50/ea07021ejw8eb3hbgkysgj2050050gli.jpg?KID=imgbed,tva&amp;Expires=1587102757&amp;ssig=E8XjfjEgN2" alt="user_image"> 
    </div> 
    <div class="comment-content  col-md-10"> 
     <p>刘老师，我在数据库中设置了联合主键，如果想插入一个条目，想要预先判断该条目的联合主键是否在数据中已经存在该怎么办呢？</p> 
     <br> 
     <div class="comment_footer small mute"> 
      <span>By&nbsp;&nbsp; 夏夜暮思 </span>&nbsp;&nbsp;&nbsp;On&nbsp;&nbsp; 
      <em>2020年4月17日 10:54</em>&nbsp;&nbsp; 
      <a class="text-info" href="/reply/2037">回复</a> 
     </div> 
     <br> 
    </div> 
   </div> 
  </div> 
  <div class="comment " style="margin-left: 0em"> 
   <div class="row"> 
    <div> 
     <img src="http://tva1.sinaimg.cn/crop.0.0.996.996.50/be0a9cbajw8fc1mr83kawj20ro0roq7p.jpg" alt="user_image"> 
    </div> 
    <div class="comment-content  col-md-10"> 
     <p>刘老师的博客是我查阅的所有教程当中令我最受益的一个</p> 
     <br> 
     <div class="comment_footer small mute"> 
      <span>By&nbsp;&nbsp; 思考问题的熊 </span>&nbsp;&nbsp;&nbsp;On&nbsp;&nbsp; 
      <em>2018年8月14日 13:03</em>&nbsp;&nbsp; 
      <a class="text-info" href="/reply/677">回复</a> 
     </div> 
     <br> 
    </div> 
   </div> 
  </div> 
  <div class="comment " style="margin-left: 4em"> 
   <div class="row"> 
    <div> 
     <img src="http://tvax1.sinaimg.cn/crop.79.178.566.566.50/005PMdg8ly8fjzip8l3ibj30k00scgr3.jpg" alt="user_image"> 
    </div> 
    <div class="comment-content  col-md-10"> 
     <p>这个教程花费了我半年时间搭建起来的。</p> 
     <br> 
     <div class="comment_footer small mute"> 
      <span> <span class="badge badge-info">&nbsp;博主</span> &nbsp;&nbsp;回复&nbsp;&nbsp; 思考问题的熊 </span> 
      <em>2018年8月14日 22:41</em>&nbsp;&nbsp; 
      <a class="text-info" href="/reply/682">回复</a> 
     </div> 
     <br> 
    </div> 
   </div> 
  </div> 
  <div class="comment " style="margin-left: 0em"> 
   <div class="row"> 
    <div> 
     <img src="http://tva2.sinaimg.cn/crop.0.0.664.664.50/8ea3178bjw8f0qgc5x05qj20ig0iggmf.jpg" alt="user_image"> 
    </div> 
    <div class="comment-content  col-md-10"> 
     <p>官网全都是英文，看得累死了；老师这博客让很多新手收益啊</p> 
     <br> 
     <div class="comment_footer small mute"> 
      <span>By&nbsp;&nbsp; jekoie </span>&nbsp;&nbsp;&nbsp;On&nbsp;&nbsp; 
      <em>2018年7月9日 15:47</em>&nbsp;&nbsp; 
      <a class="text-info" href="/reply/560">回复</a> 
     </div> 
     <br> 
    </div> 
   </div> 
  </div> 
  <div class="comment " style="margin-left: 0em"> 
   <div class="row"> 
    <div> 
     <img src="http://tva1.sinaimg.cn/crop.29.72.151.151.50/c345a2c6jw1egex1o75ogj205c071mx9.jpg" alt="user_image"> 
    </div> 
    <div class="comment-content  col-md-10"> 
     <p>学完本章，历时2晚，感觉都很有用，但是学的多了，有的印象不深，有没有实例，难免会忘掉很多 2018.1.18</p> 
     <br> 
     <div class="comment_footer small mute"> 
      <span>By&nbsp;&nbsp; 世外就是TaoYuan </span>&nbsp;&nbsp;&nbsp;On&nbsp;&nbsp; 
      <em>2018年1月18日 18:42</em>&nbsp;&nbsp; 
      <a class="text-info" href="/reply/141">回复</a> 
     </div> 
     <br> 
    </div> 
   </div> 
  </div> 
  <div class="comment " style="margin-left: 4em"> 
   <div class="row"> 
    <div> 
     <img src="https://tva4.sinaimg.cn/crop.0.0.996.996.50/006aNL6pjw8f77humm3xaj30ro0rpjt6.jpg?KID=imgbed,tva&amp;Expires=1583864750&amp;ssig=%2FVd3kTU8SC" alt="user_image"> 
    </div> 
    <div class="comment-content  col-md-10"> 
     <p>一样的感觉，不过这个教程真的是我用过的最受益的了，就是现在刚学印象不深，希望尽快能够看完并且实操</p> 
     <br> 
     <div class="comment_footer small mute"> 
      <span> 存殁233 &nbsp;&nbsp;回复&nbsp;&nbsp; 世外就是TaoYuan </span> 
      <em>2020年3月10日 23:27</em>&nbsp;&nbsp; 
      <a class="text-info" href="/reply/1959">回复</a> 
     </div> 
     <br> 
    </div> 
   </div> 
  </div> 
  <!-- 评论显示区结束--> 
  <!-- 评论区结束--> 
 </div> 
 <!-- 右侧正文栏结束 --> 
</div>]